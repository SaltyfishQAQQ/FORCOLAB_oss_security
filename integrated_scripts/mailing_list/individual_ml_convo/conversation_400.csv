timestamp,from,to,body,title,msg_file
"Fri, 08 Jan 2021 10:21:35 -0800",Brett Okken,,"Are there any plans to update xz-java to take advantage of newer
features in jdk 9+?


For example, Arrays.mismatch[1] leverages vectorized comparisons of 2
byte[]. This could be leveraged in the getMatches methods of BT4 and
HC4 as well as the 2 getMatchLen methods in LZEncoder.

Another example would be to use a VarHandle to read int values out of
a byte[][2], which would be useful for the calcHashes method in
Hash234.


[1] - 
https://docs.oracle.com/javase/9/docs/api/java/util/Arrays.html#mismatch-byte:A-int-int-byte:A-int-int-
[2] - 
https://docs.oracle.com/javase/9/docs/api/java/lang/invoke/MethodHandles.html#byteArrayViewVarHandle-java.lang.Class-java.nio.ByteOrder-

Thanks,

Brett
",[xz-devel] xz-java and newer java,msg00400.html
"Fri, 08 Jan 2021 11:36:50 -0800",Lasse Collin,Brett Okken,"On 2021-01-08 Brett Okken wrote:


There aren't much plans at all. Adding module-info.java is likely to
happen in the next release, whenever that will be.

Apache Commons Compress 1.20 requires Java 7. It depends on XZ for
Java. I think it wouldn't be good to make XZ for Java require a newer
Java version than Commons Compress but it could be discussed with
Commons Compress developers. There's a bug with .7z files that requires
changing both XZ for Java and Commons Compress so I could ask about the
Java version too.


Thanks! These sound interesting. If they make big enough difference, it
could be a good reason to require Java 9.

I will need to check out the LZDecoder improvement from the other
message too, and perhaps a few variations of it. Thanks!

There are multiple things in XZ Utils that I try to look at in the near
future so it will be a while until I will play with the Java code.

-- 
Lasse Collin  |  IRC: Larhzu @ IRCnet & Freenode
",Re: [xz-devel] xz-java and newer java,msg00402.html
"Sat, 09 Jan 2021 10:13:43 -0800",Brett Okken,Lasse Collin,"This would seem to be a potential candidate for a multi-release
jar[1], if you can figure out a reasonable way to get a build system
to generate one.


The 4 uses I found of comparing byte[] could be refactored to call a
new utility class to do the comparison. The ""regular"" implementation
could be java 7 compatible, and the jdk 9 version would be in the
META_INF folder.
Even for the java 7 compatible version, it might be worth exploring
how much improvement would come from using Unsafe to read int or long
values from the byte[] and compare those.

For Hash234, I would think the whole class could be handled for the MR jar.

[1] - https://openjdk.java.net/jeps/238

Thanks,

Brett

On Fri, Jan 8, 2021 at 1:36 PM Lasse Collin <lasse.col...@tukaani.org> wrote:
",Re: [xz-devel] xz-java and newer java,msg00407.html
"Sat, 09 Jan 2021 10:17:46 -0800",Brett Okken,Brett Okken,"Here is a class which is compatible with jdk 7. It will use a
MethodHandle to invoke Arrays.mismatch if that is found at runtime. If
that is not found, it will see if it can find Unsafe to read 4 bytes
at a time and compare as ints. If that cannot be found/loaded/invoked,
it falls back to iterating over bytes and comparing one by one.


For jdk 9, the mismatch method could instead be implemented as:
return Arrays.mismatch(a, aFromIndex, aFromIndex + length, b,
bFromIndex, bFromIndex + length);


package org.tukaani.xz.common;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.lang.reflect.Constructor;
import java.nio.ByteOrder;
import java.util.Arrays;

import sun.misc.Unsafe;

public final class ArrayUtil {

    private static interface ArrayComparer {
        int mismatch(byte[] a, int aFromIndex, byte[] b, int
bFromIndex, int length);
    }

    private static final ArrayComparer COMPARER;

    static {
        //try to create an instance using Unsafe
        ArrayComparer comparer = null;
        try {
            try {
                final MethodHandle mh =
MethodHandles.lookup().findStatic(Arrays.class, ""mismatch"",
MethodType.methodType(int.class, byte[].class, int.class, int.class,
byte[].class, int.class, int.class));
                comparer = new ArrayComparer() {
                    @Override
                    public int mismatch(byte[] a, int aFromIndex,
byte[] b, int bFromIndex, int length) {
                        try {
                            return (int) mh.invokeExact(a, aFromIndex,
aFromIndex + length, b, bFromIndex, bFromIndex + length);
                        } catch (Throwable e) {
                            if (e instanceof RuntimeException) {
                                throw (RuntimeException) e;
                            }
                            if (e instanceof Error) {
                                throw (Error) e;
                            }
                            throw new IllegalStateException(e);
                        }
                    }
                };
            } catch (Exception e) {
                //TODO: log out?
            }

            if (comparer == null) {
                Constructor<Unsafe> unsafeConstructor =
Unsafe.class.getDeclaredConstructor();
                unsafeConstructor.setAccessible(true);
                final Unsafe unsafe = unsafeConstructor.newInstance();

                //do a test read to confirm unsafe is actually functioning
                int val = unsafe.getInt(new byte[] {0,0,0,0},
Unsafe.ARRAY_BYTE_BASE_OFFSET + 0L);
                if (val != 0) {
                    throw new IllegalStateException(""invalid value: "" + val);
                }

                final boolean bigEndian = ByteOrder.BIG_ENDIAN ==
ByteOrder.nativeOrder();

                comparer = new ArrayComparer() {
                    @Override
                    public int mismatch(byte[] a, int aFromIndex,
byte[] b, int bFromIndex, int length) {
                        int i=0;
                        for (int j=length - 3; i<j; i+=4) {
                            int aVal = unsafe.getInt(a, ((long)
Unsafe.ARRAY_BYTE_BASE_OFFSET) + aFromIndex + i);
                            int bVal = unsafe.getInt(b, ((long)
Unsafe.ARRAY_BYTE_BASE_OFFSET) +  bFromIndex + i);
                            if (aVal != bVal) {
                                final int diff = aVal ^ bVal;
                                //getInt interprets in platform byte
order. the concept of ""leading zeros"" being bytes
                                //in encounter order is true for big endian
                                //for little endian platform, the
trailing zeros gives the encounter order result
                                final int leadingZeros = bigEndian ?
Integer.numberOfLeadingZeros(diff) :
Integer.numberOfTrailingZeros(diff);
                                return i + (leadingZeros / Byte.SIZE);
                            }
                        }
                        for ( ; i<length; ++i) {
                            if (a[aFromIndex + i] != b[bFromIndex + i]) {
                                return i;
                            }
                        }
                        return -1;
                    }
                };
            }
        } catch (Throwable t) {
            //TODO: log out?

            //fall back to ""normal"" implementation
            comparer = new ArrayComparer() {
                @Override
                public int mismatch(byte[] a, int aFromIndex, byte[]
b, int bFromIndex, int length) {
                    for (int i=0; i<length; ++i) {
                        if (a[aFromIndex + i] != b[bFromIndex + i]) {
                            return i;
                        }
                    }
                    return -1;
                }
            };
        }

        COMPARER = comparer;
    }

    public static int mismatch(byte[] a, int aFromIndex, byte[] b, int
bFromIndex, int length) {
       return COMPARER.mismatch(a, aFromIndex, b, bFromIndex, length);
    }

    private ArrayUtil() {
    }
}
",Re: [xz-devel] xz-java and newer java,msg00408.html
"Mon, 11 Jan 2021 08:04:19 -0800",Lasse Collin,Brett Okken,"On 2021-01-09 Brett Okken wrote:


I suppose it can be done. The build system uses Apache Ant. From some
sources I've understood that there are more modern alternatives but I
haven't had any interest or energy to learn more as Ant seems to still
work OK.


All these sound like worth checking out.

On 2021-01-09 Brett Okken wrote:

Thanks! There are several XZ Utils related tasks I hope to get done (of
which not all have been mentioned on xz-devel), so I won't think much
about XZ for Java in the near future, I'm sorry.

I assume that multi-release method has no performance overhead since
the runtime will load the best .class file and that's it. How the other
methods like using an utility class or looking for available methods at
runtime compare to pure multi-release method in terms of performance?
Perhaps this is a stupid question but I have so little Java experience
that I don't have a clue about this.

If you have time and interest, it would be valuable to know which
tricks provide the largest performance improvements. However, I repeat
that I cannot spend much time on this in the near future even though I
think it would be good to have such improvements in XZ for Java.

Thanks!

-- 
Lasse Collin  |  IRC: Larhzu @ IRCnet & Freenode
",Re: [xz-devel] xz-java and newer java,msg00414.html
"Mon, 11 Jan 2021 16:13:05 -0800",Brett Okken,Lasse Collin,"I threw together a quick jmh test, and there is no value in the
changes to Hash234.


For the array mismatch, the results are kind of interesting. My
observation, stepping through some compression uses, is that the
comparison length is typically 100-200 bytes in length, but the actual
match length is typically fairly short. This is obviously going to be
highly dependent on data, and I was using raw image data for
observation. Content like xml or json might have longer matches. So I
set up a benchmark which is always comparing 128 bytes and the
mismatch occurs after various ""lengths"":

Benchmark                                      (length)  Mode  Cnt
Score   Error  Units
ArrayMismatchBenchmark.legacyMismatch_nomatch         0  avgt    5
3.198 ± 0.168  ns/op
ArrayMismatchBenchmark.legacyMismatch_nomatch         1  avgt    5
5.607 ± 0.048  ns/op
ArrayMismatchBenchmark.legacyMismatch_nomatch         2  avgt    5
5.852 ± 0.053  ns/op
ArrayMismatchBenchmark.legacyMismatch_nomatch         7  avgt    5
12.703 ± 0.350  ns/op
ArrayMismatchBenchmark.legacyMismatch_nomatch        13  avgt    5
18.275 ± 0.228  ns/op
ArrayMismatchBenchmark.legacyMismatch_nomatch        57  avgt    5
42.313 ± 0.450  ns/op
ArrayMismatchBenchmark.legacyMismatch_nomatch        97  avgt    5
89.410 ± 2.927  ns/op
ArrayMismatchBenchmark.arraysMismatch_nomatch         0  avgt    5
4.629 ± 0.035  ns/op
ArrayMismatchBenchmark.arraysMismatch_nomatch         1  avgt    5
9.515 ± 0.096  ns/op
ArrayMismatchBenchmark.arraysMismatch_nomatch         2  avgt    5
9.526 ± 0.132  ns/op
ArrayMismatchBenchmark.arraysMismatch_nomatch         7  avgt    5
9.581 ± 0.395  ns/op
ArrayMismatchBenchmark.arraysMismatch_nomatch        13  avgt    5
9.781 ± 0.133  ns/op
ArrayMismatchBenchmark.arraysMismatch_nomatch        57  avgt    5
9.846 ± 0.182  ns/op
ArrayMismatchBenchmark.arraysMismatch_nomatch        97  avgt    5
10.809 ± 0.307  ns/op
ArrayMismatchBenchmark.intMismatch_nomatch            0  avgt    5
3.417 ± 0.018  ns/op
ArrayMismatchBenchmark.intMismatch_nomatch            1  avgt    5
3.412 ± 0.011  ns/op
ArrayMismatchBenchmark.intMismatch_nomatch            2  avgt    5
3.414 ± 0.032  ns/op
ArrayMismatchBenchmark.intMismatch_nomatch            7  avgt    5
5.401 ± 0.207  ns/op
ArrayMismatchBenchmark.intMismatch_nomatch           13  avgt    5
8.311 ± 0.070  ns/op
ArrayMismatchBenchmark.intMismatch_nomatch           57  avgt    5
20.536 ± 0.556  ns/op
ArrayMismatchBenchmark.intMismatch_nomatch           97  avgt    5
30.969 ± 0.318  ns/op
ArrayMismatchBenchmark.longMismatch_nomatch           0  avgt    5
4.399 ± 0.082  ns/op
ArrayMismatchBenchmark.longMismatch_nomatch           1  avgt    5
4.390 ± 0.068  ns/op
ArrayMismatchBenchmark.longMismatch_nomatch           2  avgt    5
4.398 ± 0.033  ns/op
ArrayMismatchBenchmark.longMismatch_nomatch           7  avgt    5
4.403 ± 0.110  ns/op
ArrayMismatchBenchmark.longMismatch_nomatch          13  avgt    5
6.564 ± 0.398  ns/op
ArrayMismatchBenchmark.longMismatch_nomatch          57  avgt    5
11.548 ± 0.331  ns/op
ArrayMismatchBenchmark.longMismatch_nomatch          97  avgt    5
16.335 ± 0.119  ns/op

I labeled the current behavior as ""legacy"".
The Arrays.mismatch is significantly slower when the mismatch occurs
early in the array and significantly faster when the mismatch occurs
later.
Comparing an int (4 bytes) at a time is a clear winner if the mismatch
occurs in those 4 bytes, which appeared to be 90+% of the calls I
observed.
Comparing a long (8 bytes) at a time is faster than the current
behavior unless it is the first byte which does not match, but slower
than comparing ints if the mismatch occurs in the first 4 bytes.

I wrote this test using jdk 9 VarHandle to read the ints and longs
from the byte[], but the same thing can be achieved using
sun.misc.Unsafe. I will add that as a case in the benchmark, but it is
expected to be similar to VarHandle (maybe slightly faster).

Brett

On Mon, Jan 11, 2021 at 10:04 AM Lasse Collin <lasse.col...@tukaani.org> wrote:
",Re: [xz-devel] xz-java and newer java,msg00419.html
"Tue, 12 Jan 2021 08:17:35 -0800",Brett Okken,Brett Okken,"It turns out that reading the longs in native byte order provides
noticeable improvement.
I did find that there was cost overhead of ~1 ns/op by using an
interface/implementation to flex behavior if Unsafe could not be
loaded. That cost goes away by using java.lang.invoke.MethodHandle.
So here is an updated jdk 7 compatible ArrayUtil implementation which
matches current performance if the first byte does not match and is
faster in every other scenario. The gap in performance grows as more
bytes actually match. At 2 bytes, it takes roughly half the time. At
97 bytes, it takes less than ten percent of the time.


Here are the benchmark results:

Benchmark                                        (length)  Mode  Cnt
Score   Error  Units
ArrayMismatchBenchmark.comparerMismatch_nomatch         0  avgt    5
4.487 ± 0.059  ns/op
ArrayMismatchBenchmark.comparerMismatch_nomatch         1  avgt    5
4.515 ± 0.102  ns/op
ArrayMismatchBenchmark.comparerMismatch_nomatch         2  avgt    5
4.523 ± 0.023  ns/op
ArrayMismatchBenchmark.comparerMismatch_nomatch         7  avgt    5
5.164 ± 0.098  ns/op
ArrayMismatchBenchmark.comparerMismatch_nomatch        13  avgt    5
5.748 ± 0.974  ns/op
ArrayMismatchBenchmark.comparerMismatch_nomatch        57  avgt    5
10.060 ± 1.135  ns/op
ArrayMismatchBenchmark.comparerMismatch_nomatch        97  avgt    5
11.518 ± 0.418  ns/op
ArrayMismatchBenchmark.legacyMismatch_nomatch           0  avgt    5
3.259 ± 0.069  ns/op
ArrayMismatchBenchmark.legacyMismatch_nomatch           1  avgt    5
5.712 ± 0.070  ns/op
ArrayMismatchBenchmark.legacyMismatch_nomatch           2  avgt    5
6.017 ± 0.300  ns/op
ArrayMismatchBenchmark.legacyMismatch_nomatch           7  avgt    5
12.949 ± 0.163  ns/op
ArrayMismatchBenchmark.legacyMismatch_nomatch          13  avgt    5
18.696 ± 0.551  ns/op
ArrayMismatchBenchmark.legacyMismatch_nomatch          57  avgt    5
43.232 ± 1.015  ns/op
ArrayMismatchBenchmark.legacyMismatch_nomatch          97  avgt    5
90.599 ± 0.794  ns/op
ArrayMismatchBenchmark.unsafeMisMatch_nomatch           0  avgt    5
3.246 ± 0.138  ns/op
ArrayMismatchBenchmark.unsafeMisMatch_nomatch           1  avgt    5
3.225 ± 0.042  ns/op
ArrayMismatchBenchmark.unsafeMisMatch_nomatch           2  avgt    5
3.242 ± 0.043  ns/op
ArrayMismatchBenchmark.unsafeMisMatch_nomatch           7  avgt    5
3.244 ± 0.048  ns/op
ArrayMismatchBenchmark.unsafeMisMatch_nomatch          13  avgt    5
3.477 ± 0.028  ns/op
ArrayMismatchBenchmark.unsafeMisMatch_nomatch          57  avgt    5
5.968 ± 0.553  ns/op
ArrayMismatchBenchmark.unsafeMisMatch_nomatch          97  avgt    5
7.182 ± 0.080  ns/op
ArrayMismatchBenchmark.utilMismatch_nomatch             0  avgt    5
3.219 ± 0.044  ns/op
ArrayMismatchBenchmark.utilMismatch_nomatch             1  avgt    5
3.217 ± 0.054  ns/op
ArrayMismatchBenchmark.utilMismatch_nomatch             2  avgt    5
3.217 ± 0.069  ns/op
ArrayMismatchBenchmark.utilMismatch_nomatch             7  avgt    5
3.206 ± 0.047  ns/op
ArrayMismatchBenchmark.utilMismatch_nomatch            13  avgt    5
3.509 ± 0.218  ns/op
ArrayMismatchBenchmark.utilMismatch_nomatch            57  avgt    5
5.870 ± 0.063  ns/op
ArrayMismatchBenchmark.utilMismatch_nomatch            97  avgt    5
7.178 ± 0.267  ns/op

The ""comparer"" implementation is using interface with different
implementations based on whether Unsafe could be loaded.
The ""unsafe"" implementation is directly using the Unsafe class.
The ""util"" implementation is using the ArrayUtil class below.


package org.tukaani.xz.common;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.lang.reflect.Constructor;
import java.nio.ByteOrder;

public final class ArrayUtil {

    /**
     * MethodHandle to the actual mismatch method to use at runtime.
     */
    private static final MethodHandle MISMATCH;

    /**
     * If {@code sun.misc.Unsafe} can be loaded, this is MethodHandle
bound to an instance of Unsafe for method {@code long getLong(Object,
long)}.
     */
    private static final MethodHandle UNSAFE_GET_LONG;

    /**
     * MethodHandle to either {@link Long#numberOfLeadingZeros(long)}
or {@link Long#numberOfTrailingZeros(long)} depending on {@link
ByteOrder#nativeOrder()}.
     */
    private static final MethodHandle LEADING_ZEROS;

    /**
     * Populated from reflected read of {@code
sun.misc.Unsafe.ARRAY_BYTE_BASE_OFFSET}.
     */
    private static final long ARRAY_BASE_OFFSET;

    static {
        //try to create an instance using Unsafe
        long arrayBaseOffset = 0;
        MethodHandle unsafeGetLong = null;
        MethodHandle leadingZeros = null;
        MethodHandle mismatch = null;
        final MethodHandles.Lookup lookup = MethodHandles.lookup();
        final MethodType mismatchType =
MethodType.methodType(int.class, byte[].class, int.class,
byte[].class, int.class, int.class);
        try {
            Class<?> unsafeClazz = Class.forName(""sun.misc.Unsafe"", true, null);
            Constructor<?> unsafeConstructor =
unsafeClazz.getDeclaredConstructor();
            unsafeConstructor.setAccessible(true);
            Object unsafe = unsafeConstructor.newInstance();

            arrayBaseOffset =
unsafeClazz.getField(""ARRAY_BYTE_BASE_OFFSET"").getLong(null);

            MethodHandle virtualGetLong =
lookup.findVirtual(unsafeClazz, ""getLong"",
MethodType.methodType(long.class, Object.class, long.class));
            unsafeGetLong = virtualGetLong.bindTo(unsafe);

            // do a test read to confirm unsafe is actually functioning
            long val = (long) unsafeGetLong.invokeExact((Object) new
byte[] { 0, 0, 0, 0, 0, 0, 0, 0 }, arrayBaseOffset + 0L);
            if (val != 0) {
                throw new IllegalStateException(""invalid value: "" + val);
            }

            final boolean bigEndian = ByteOrder.BIG_ENDIAN ==
ByteOrder.nativeOrder();

            //getInt interprets in platform byte order. the concept of
""leading zeros"" being bytes
            //in encounter order is true for big endian
            //for little endian platform, the trailing zeros gives the
encounter order result
            leadingZeros = lookup.findStatic(Long.class, bigEndian ?
""numberOfLeadingZeros"" : ""numberOfTrailingZeros"",
MethodType.methodType(int.class, long.class));
            mismatch = lookup.findStatic(ArrayUtil.class,
""unsafeMismatch"", mismatchType);
        } catch (Throwable t) {
            //TODO: log out?
            unsafeGetLong = null;
            leadingZeros = null;
            try {
                mismatch = lookup.findStatic(ArrayUtil.class,
""legacyMismatch"", mismatchType);
            } catch (Exception e) {
                throw new IllegalStateException(e);
            }
        }

        UNSAFE_GET_LONG = unsafeGetLong;
        ARRAY_BASE_OFFSET = arrayBaseOffset;
        LEADING_ZEROS = leadingZeros;
        MISMATCH = mismatch;
    }

    /**
     * Compares the values in <i>a</i> and <i>b</i> and returns the
index of the first {@code byte} which differs.
     * @param a The first {@code byte[]} for comparison.
     * @param aFromIndex The offset into <i>a</i> to start reading from.
     * @param b The second {@code byte[]} for comparison.
     * @param bFromIndex The offset into <i>b</i> to start reading from.
     * @param length The number of bytes to compare.
     * @return The offset from the starting indexes of the first byte
which differs or {@code -1} if all match.
     */
    public static int mismatch(byte[] a, int aFromIndex, byte[] b, int
bFromIndex, int length) {
       try {
          return (int) MISMATCH.invokeExact(a, aFromIndex, b,
bFromIndex, length);
       } catch (RuntimeException e) {
           throw e;
       } catch (Error e) {
           throw e;
       } catch (Throwable t) {
           throw new RuntimeException(t);
       }
    }

    /**
     * Uses {@code UNSAFE_GET_LONG} to compare 8 bytes at a time.
     */
    @SuppressWarnings(""unused"")
    private static int unsafeMismatch(byte[] a, int aFromIndex, byte[]
b, int bFromIndex, int length) throws Throwable {
        //TODO: should these asserts be uncommented and/or should real
verification be done?
        //by using Unsafe, we can actually SIGSEGV if length is not
valid for a or b.
//        assert a.length >= aFromIndex + length;
//        assert b.length >= bFromIndex + length;
        int i=0;
        for (int j=length - 7; i<j; i+=8) {
            final long aVal = (long)
UNSAFE_GET_LONG.invokeExact((Object) a, ARRAY_BASE_OFFSET + aFromIndex
+ i);
            final long bVal = (long)
UNSAFE_GET_LONG.invokeExact((Object) b, ARRAY_BASE_OFFSET + bFromIndex
+ i);
            if (aVal != bVal) {
                //this returns a value where bits which match are 0
and bits which differ are 1
                final long diff = aVal ^ bVal;
                //the first (in native byte order) bit which differs
tells us which byte differed
                final int leadingZeros = (int) LEADING_ZEROS.invokeExact(diff);
                return i + (leadingZeros / Byte.SIZE);
            }
        }
        for ( ; i<length; ++i) {
            if (a[aFromIndex + i] != b[bFromIndex + i]) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Simply loops over all of the bytes, comparing one at a time.
     */
    @SuppressWarnings(""unused"")
    private static int legacyMismatch(byte[] a, int aFromIndex, byte[]
b, int bFromIndex, int length) {
        for (int i=0; i<length; ++i) {
            if (a[aFromIndex + i] != b[bFromIndex + i]) {
                return i;
            }
        }
        return -1;
    }

    private ArrayUtil() {
    }
}

On Mon, Jan 11, 2021 at 6:12 PM Brett Okken <brett.okken...@gmail.com> wrote:
",Re: [xz-devel] xz-java and newer java,msg00420.html
"Wed, 13 Jan 2021 13:30:40 -0800",Brett Okken,Brett Okken,"I have continued to refine the changes around the array comparisons
and think I am pretty well done there.


I did a small benchmark measuring the time to compress 3 different
files using new XZOutputStream(cos, new LZMA2Options()). Where cos was
an OutputStream which simply calculated the crc32 of the content
written.

The ihe_ovly.pr.dcm is a ~66KB binary file.
The image1.dcm file is a ~26MB binary file with some metadata wrapping
a grayscale bmp.
The large.xml file is a ~51MB formatted utf-8 xml file.

1.8
Benchmark                                 (file)  Mode  Cnt     Score
   Error  Units
XZCompressionBenchmark.compress  ihe_ovly_pr.dcm  avgt    5     9.575
±   0.322  ms/op
XZCompressionBenchmark.compress       image1.dcm  avgt    5  6767.376
± 675.373  ms/op
XZCompressionBenchmark.compress        large.xml  avgt    5  9680.569
± 207.521  ms/op

1.9-SNAPSHOT
Benchmark                                 (file)  Mode  Cnt     Score
  Error  Units
XZCompressionBenchmark.compress  ihe_ovly_pr.dcm  avgt    5     7.888
±  0.443  ms/op
XZCompressionBenchmark.compress       image1.dcm  avgt    5  6144.748
± 71.551  ms/op
XZCompressionBenchmark.compress        large.xml  avgt    5  7904.019
± 26.316  ms/op

These results are from 64 bit windows using open jdk 11.0.6.
The results are 9-18% faster across the 3 different file types.

I made a small change to ArrayUtil from what I sent previously. When
everything matches, it now returns length rather than -1.

The remaining changes are:

BT4:
in getMatches()

        if (matches.count > 0) {
            while (lenBest < matchLenLimit && buf[readPos + lenBest - delta2]
                                              == buf[readPos + lenBest])
                ++lenBest;

Changes to:
        if (matches.count > 0) {
            lenBest += ArrayUtil.mismatch(buf, readPos + lenBest -
delta2, buf, readPos + lenBest, matchLenLimit - lenBest);

Further down, inside a while(true) block,

            if (buf[readPos + len - delta] == buf[readPos + len]) {
                while (++len < matchLenLimit)
                    if (buf[readPos + len - delta] != buf[readPos + len])
                        break;

Changes to:
            int mismatch = ArrayUtil.mismatch(buf, readPos + len -
delta, buf, readPos + len, matchLenLimit - len);
            if (mismatch != 0) {
                len += mismatch;

in skip(int, int)

            if (buf[readPos + len - delta] == buf[readPos + len]) {
                // No need to look for longer matches than niceLenLimit
                // because we only are updating the tree, not returning
                // matches found to the caller.
                do {
                    if (++len == niceLenLimit) {
                        tree[ptr1] = tree[pair];
                        tree[ptr0] = tree[pair + 1];
                        return;
                    }
                } while (buf[readPos + len - delta] == buf[readPos + len]);
            }

Changes to:
            // No need to look for longer matches than niceLenLimit
            // because we only are updating the tree, not returning
            // matches found to the caller.
            int mismatch = ArrayUtil.mismatch(buf, readPos + len -
delta, buf, readPos + len, niceLenLimit);
            if (mismatch == niceLenLimit) {
                tree[ptr1] = tree[pair];
                tree[ptr0] = tree[pair + 1];
                return;
            }
            len += mismatch;


In HC4, both changes are in getMatches()

        if (matches.count > 0) {
            while (lenBest < matchLenLimit && buf[readPos + lenBest - delta2]
                                              == buf[readPos + lenBest])
                ++lenBest;

Changes to:
        if (matches.count > 0) {
            lenBest += ArrayUtil.mismatch(buf, readPos + lenBest -
delta2, buf, readPos + lenBest, matchLenLimit - lenBest);

And:

            // Test the first byte and the first new byte that would give us
            // a match that is at least one byte longer than lenBest. This
            // too short matches get quickly skipped.
            if (buf[readPos + lenBest - delta] == buf[readPos + lenBest]
                    && buf[readPos - delta] == buf[readPos]) {
                // Calculate the length of the match.
                int len = 0;
                while (++len < matchLenLimit)
                    if (buf[readPos + len - delta] != buf[readPos + len])
                        break;

                // Use the match if and only if it is better than the longest
                // match found so far.
                if (len > lenBest) {
                    lenBest = len;
                    matches.len[matches.count] = len;
                    matches.dist[matches.count] = delta - 1;
                    ++matches.count;

                    // Return if it is long enough (niceLen or reached the
                    // end of the dictionary).
                    if (len >= niceLenLimit)
                        return matches;
                }
            }

Changes to:
            final int mismatch = ArrayUtil.mismatch(buf, readPos -
delta, buf, readPos, matchLenLimit);
            //use the match iff it is better than the longest match found so far
            if (mismatch > lenBest) {
                lenBest = mismatch;
                matches.len[matches.count] = mismatch;
                matches.dist[matches.count] = delta - 1;
                ++matches.count;

                // Return if it is long enough (niceLen or reached the
                // end of the dictionary).
                if (mismatch >= niceLenLimit)
                    return matches;
            }

Finally, in LZEncoder, the 2 getMatchLen methods were changed to:

    public int getMatchLen(int dist, int lenLimit) {
        final int backPos = readPos - dist - 1;
        return ArrayUtil.mismatch(buf, readPos, buf, backPos, lenLimit);
    }

    public int getMatchLen(int forward, int dist, int lenLimit) {
        final int curPos = readPos + forward;
        final int backPos = curPos - dist - 1;
        return ArrayUtil.mismatch(buf, curPos, buf, backPos, lenLimit);
    }

On Tue, Jan 12, 2021 at 10:17 AM Brett Okken <brett.okken...@gmail.com> wrote:
",Re: [xz-devel] xz-java and newer java,msg00421.html
"Sat, 16 Jan 2021 13:26:26 -0800",Brett Okken,Brett Okken,"Lasse,

I have found a way to use VarHandle byte array access at runtime in
code which is compile time compatible with jdk 7. So here is an
updated ArrayUtil class which will use a VarHandle to read long values
in jdk 9+. If that is not available, it will attempt to use
sun.misc.Unsafe. If that cannot be found, it falls back to standard
byte by byte comparison.
I did add an index bounds check for the unsafe implementation and
found it had minimal impact on over all performance.
Using VarHandle (at least on jdk 11) offers very similar performance
to Unsafe across all 3 files I used for benchmarking.


--Baseline 1.8
Benchmark                                 (file)  Mode  Cnt      Score
    Error  Units
XZCompressionBenchmark.compress  ihe_ovly_pr.dcm  avgt    4      9.558
±   0.239  ms/op
XZCompressionBenchmark.compress       image1.dcm  avgt    4   6553.304
± 112.475  ms/op
XZCompressionBenchmark.compress        large.xml  avgt    4  10592.151
± 291.527  ms/op

--Unsafe
Benchmark                                 (file)  Mode  Cnt     Score
   Error  Units
XZCompressionBenchmark.compress  ihe_ovly_pr.dcm  avgt    4     7.699
±   0.058  ms/op
XZCompressionBenchmark.compress       image1.dcm  avgt    4  6001.170
± 143.814  ms/op
XZCompressionBenchmark.compress        large.xml  avgt    4  7853.963
±  83.753  ms/op

--VarHandle
Benchmark                                 (file)  Mode  Cnt     Score
   Error  Units
XZCompressionBenchmark.compress  ihe_ovly_pr.dcm  avgt    4     7.630
±   0.542  ms/op
XZCompressionBenchmark.compress       image1.dcm  avgt    4  5872.098
±  71.185  ms/op
XZCompressionBenchmark.compress        large.xml  avgt    4  8239.880
± 346.036  ms/op

I know you said you were not going to be able to work on xz-java for
awhile, but given these benchmark results, which really exceeded my
expectations, could this get some priority to release?


package org.tukaani.xz.common;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.nio.ByteOrder;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Utilities for optimized array interactions.
 *
 * @author Brett Okken
 */
public final class ArrayUtil {

    /**
     * MethodHandle to the actual mismatch method to use at runtime.
     */
    private static final MethodHandle MISMATCH;

    /**
     * If {@code sun.misc.Unsafe} can be loaded, this is MethodHandle
bound to an instance of Unsafe for method {@code long getLong(Object,
long)}.
     */
    private static final MethodHandle UNSAFE_GET_LONG;

    /**
     * MethodHandle to either {@link Long#numberOfLeadingZeros(long)}
or {@link Long#numberOfTrailingZeros(long)} depending on {@link
ByteOrder#nativeOrder()}.
     */
    private static final MethodHandle LEADING_ZEROS;

    /**
     * Populated from reflected read of {@code
sun.misc.Unsafe.ARRAY_BYTE_BASE_OFFSET}.
     */
    private static final long ARRAY_BASE_OFFSET;

    /**
     * {@code MethodHandle} for a jdk 9+ {@code
byteArrayViewVarHandle} for {@code long[]} using the {@link
ByteOrder#nativeOrder()}.
     * The method signature is {@code long get(byte[], int)}.
     */
    private static final MethodHandle VAR_HANDLE_GET_LONG;

    static {
        final Logger logger = Logger.getLogger(ArrayUtil.class.getName());
        MethodHandle leadingZeros = null;
        MethodHandle varHandleGetLong = null;
        MethodHandle unsafeGetLong = null;
        long arrayBaseOffset = 0;
        MethodHandle mismatch = null;
        final MethodHandles.Lookup lookup = MethodHandles.lookup();
        final MethodType mismatchType =
MethodType.methodType(int.class, byte[].class, int.class,
byte[].class, int.class, int.class);
        try {
            //getLong interprets in platform byte order. the concept
of ""leading zeros"" being bytes
            //in encounter order is true for big endian
            //for little endian platform, the trailing zeros gives the
encounter order result
            leadingZeros = lookup.findStatic(Long.class,
                                             ByteOrder.BIG_ENDIAN ==
ByteOrder.nativeOrder()
                                                 ?
""numberOfLeadingZeros"" : ""numberOfTrailingZeros"",

MethodType.methodType(int.class, long.class));

            //first try to load byteArrayViewVarHandle for a long[]
            try {
                final Class<?> varHandleClazz =
Class.forName(""java.lang.invoke.VarHandle"", true, null);
                final Method byteArrayViewHandle =
MethodHandles.class.getDeclaredMethod(""byteArrayViewVarHandle"", new
Class[] {Class.class, ByteOrder.class});
                final Object varHandle =
byteArrayViewHandle.invoke(null, long[].class,
ByteOrder.nativeOrder());
                final Class<?> accessModeEnum =
Class.forName(""java.lang.invoke.VarHandle$AccessMode"", true, null);
                @SuppressWarnings({ ""unchecked"", ""rawtypes"" })
                final Object getAccessModeEnum =
Enum.valueOf((Class)accessModeEnum, ""GET"");
                final Method toMethodHandle =
varHandleClazz.getDeclaredMethod(""toMethodHandle"", accessModeEnum);
                varHandleGetLong = (MethodHandle)
toMethodHandle.invoke(varHandle, getAccessModeEnum);
                mismatch = lookup.findStatic(ArrayUtil.class,
""varHandleMismatch"", mismatchType);
                logger.finest(""byte[] comparison using VarHandle"");
            } catch (Throwable t) {
                logger.log(Level.FINE, ""failed trying to load a
MethodHandle to invoke get on a byteArrayViewVarHandle for a long[]"",
t);
                unsafeGetLong = null;
                mismatch = null;
            }

            //if byteArrayViewVarHandle for a long[] could not be
loaded, then try to load sun.misc.Unsafe
            if (mismatch == null) {
                Class<?> unsafeClazz =
Class.forName(""sun.misc.Unsafe"", true, null);
                Constructor<?> unsafeConstructor =
unsafeClazz.getDeclaredConstructor();
                unsafeConstructor.setAccessible(true);
                Object unsafe = unsafeConstructor.newInstance();

                arrayBaseOffset =
unsafeClazz.getField(""ARRAY_BYTE_BASE_OFFSET"").getLong(null);

                MethodHandle virtualGetLong =
lookup.findVirtual(unsafeClazz, ""getLong"",
MethodType.methodType(long.class, Object.class, long.class));
                unsafeGetLong = virtualGetLong.bindTo(unsafe);

                // do a test read to confirm unsafe is actually functioning
                long val = (long) unsafeGetLong.invokeExact((Object)
new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 }, arrayBaseOffset + 0L);
                if (val != 0) {
                    throw new IllegalStateException(""invalid value: "" + val);
                }
                mismatch = lookup.findStatic(ArrayUtil.class,
""unsafeMismatch"", mismatchType);
                logger.finest(""byte[] comparisons using Unsafe"");
            }
        } catch (Throwable t) {
            logger.log(Level.FINE, ""failed trying to load means to
compare byte[] by longs"", t);
            logger.finest(""byte[] comparisons byte by byte"");
            varHandleGetLong = null;
            unsafeGetLong = null;
            leadingZeros = null;
            try {
                mismatch = lookup.findStatic(ArrayUtil.class,
""legacyMismatch"", mismatchType);
            } catch (Exception e) {
                throw new IllegalStateException(e);
            }
        }

        VAR_HANDLE_GET_LONG = varHandleGetLong;
        UNSAFE_GET_LONG = unsafeGetLong;
        ARRAY_BASE_OFFSET = arrayBaseOffset;
        LEADING_ZEROS = leadingZeros;
        MISMATCH = mismatch;
    }

    /**
     * Compares the values in <i>a</i> and <i>b</i> and returns the
index of the first {@code byte} which differs.
     * @param a The first {@code byte[]} for comparison.
     * @param aFromIndex The offset into <i>a</i> to start reading from.
     * @param b The second {@code byte[]} for comparison.
     * @param bFromIndex The offset into <i>b</i> to start reading from.
     * @param length The number of bytes to compare.
     * @return The offset from the starting indexes of the first byte
which differs. If all match, <i>length</i> will be returned.
     */
    public static int mismatch(byte[] a, int aFromIndex, byte[] b, int
bFromIndex, int length) {
       try {
          return (int) MISMATCH.invokeExact(a, aFromIndex, b,
bFromIndex, length);
       } catch (RuntimeException e) {
           throw e;
       } catch (Error e) {
           throw e;
       } catch (Throwable t) {
           throw new RuntimeException(t);
       }
    }

    /**
     * Uses {@link #VAR_HANDLE_GET_LONG} to compare 8 bytes at a time.
     */
    @SuppressWarnings(""unused"")
    private static int varHandleMismatch(byte[] a, int aFromIndex,
byte[] b, int bFromIndex, int length) throws Throwable {
        //while we could do an index check, the VarHandle call
incorporates a check, making any check here duplicative
        int i=0;
        for (int j=length - 7; i<j; i+=8) {
            final long aVal = (long)
VAR_HANDLE_GET_LONG.invokeExact(a, aFromIndex + i);
            final long bVal = (long)
VAR_HANDLE_GET_LONG.invokeExact(b, bFromIndex + i);
            if (aVal != bVal) {
                //this returns a value where bits which match are 0
and bits which differ are 1
                final long diff = aVal ^ bVal;
                //the first (in native byte order) bit which differs
tells us which byte differed
                final int leadingZeros = (int) LEADING_ZEROS.invokeExact(diff);
                return i + (leadingZeros / Byte.SIZE);
            }
        }
        for ( ; i<length; ++i) {
            if (a[aFromIndex + i] != b[bFromIndex + i]) {
                return i;
            }
        }
        return length;
    }

    /**
     * Uses {@code UNSAFE_GET_LONG} to compare 8 bytes at a time.
     */
    @SuppressWarnings(""unused"")
    private static int unsafeMismatch(byte[] a, int aFromIndex, byte[]
b, int bFromIndex, int length) throws Throwable {
        //it is important to check the indexes prior to making the
Unsafe calls, as Unsafe does not validate
        //and could result in SIGSEGV if out of bounds
        if (aFromIndex < 0 || aFromIndex + length > a.length ||
bFromIndex < 0 || bFromIndex + length > b.length) {
            throw new ArrayIndexOutOfBoundsException();
        }
        int i=0;
        for (int j=length - 7; i<j; i+=8) {
            final long aVal = (long)
UNSAFE_GET_LONG.invokeExact((Object) a, ARRAY_BASE_OFFSET + aFromIndex
+ i);
            final long bVal = (long)
UNSAFE_GET_LONG.invokeExact((Object) b, ARRAY_BASE_OFFSET + bFromIndex
+ i);
            if (aVal != bVal) {
                //this returns a value where bits which match are 0
and bits which differ are 1
                final long diff = aVal ^ bVal;
                //the first (in native byte order) bit which differs
tells us which byte differed
                final int leadingZeros = (int) LEADING_ZEROS.invokeExact(diff);
                return i + (leadingZeros / Byte.SIZE);
            }
        }
        for ( ; i<length; ++i) {
            if (a[aFromIndex + i] != b[bFromIndex + i]) {
                return i;
            }
        }
        return length;
    }

    /**
     * Simply loops over all of the bytes, comparing one at a time.
     */
    @SuppressWarnings(""unused"")
    private static int legacyMismatch(byte[] a, int aFromIndex, byte[]
b, int bFromIndex, int length) {
        for (int i=0; i<length; ++i) {
            if (a[aFromIndex + i] != b[bFromIndex + i]) {
                return i;
            }
        }
        return length;
    }

    private ArrayUtil() {
    }
}
",Re: [xz-devel] xz-java and newer java,msg00423.html
"Mon, 18 Jan 2021 13:53:15 -0800",Lasse Collin,Brett Okken,"On 2021-01-11 Brett Okken wrote:


OK, let's forget that then.

On 2021-01-16 Brett Okken wrote:

Sounds promising. :-) You have already done quite a bit of work in both
writing code and benchmarking. Thank you!

The method you ended up is similar to src/liblzma/common/memcmplen.h
in XZ Utils. There 8-byte version is used on 64-bit systems and 4-byte
version on 32-bit systems. In XZ Utils, SSE2 version (16-byte
comparison) is faster than 4-byte compare on 32-bit x86, but on x86-64
the 8-byte version has similar speed or is faster than the SSE2 version
(it depends on the CPU).

Have you tested with 32-bit Java too? It's quite possible that it's
better to use ints than longs on 32-bit system. If so, that should be
detected at runtime too, I guess.

In XZ Utils the arrays have extra room at the end so that memcmplen.h
can always read 4/8/16 bytes at a time. Since this is easy to do, I
think it should be done in XZ for Java too to avoid special handling of
the last bytes.


Since Java in general is memory safe, having bound checks with Unsafe is
nice as long as it doesn't hurt performance too much. This

        if (aFromIndex < 0 || aFromIndex + length > a.length ||
            bFromIndex < 0 || bFromIndex + length > b.length) {

is a bit relaxed though since it doesn't catch integer overflows.
Something like this would be more strict:

        if (length < 0 ||
            aFromIndex < 0 || aFromIndex > a.length - length ||
            bFromIndex < 0 || bFromIndex > b.length - length) {


OK. I cannot comment the details much because I'm not familiar with
either API for now.

Comparing byte arrays as ints or longs results in unaligned/misaligned
memory access. MethodHandles.byteArrayViewVarHandle docs say that this
is OK. A quick web search gave me an impression that it might not be
safe with Unsafe though. Can you verify how it is with Unsafe? If it
isn't allowed, dropping support for Unsafe may be fine. It's just the
older Java versions that would use it anyway.

It is *essential* that the code works well also on archs that don't
have fast unaligned access. Even if the VarHandle method is safe, it's
not clear how the performance is on archs that don't support fast
unaligned access. It would be bad to add an optimization that is good
on x86-64 but counter-productive on some other archs. One may need
arch-specific code just like there is in XZ Utils, although on the
other hand it would be nice to keep the Java code less complicated.

Do you have a way to check how these methods behave on Android and ARM?
(I understand that this might be too much work to check. This may be
skipped.)

I wish to add module-info.java in the next release. Do these new
methods affect what should be in module-info.java? With the current
code this seems to be enough:

    module org.tukaani.xz {
        exports org.tukaani.xz;
    }


Seems that Java might not optimize that division to a right shift. It
could be better to use ""leadingZeros >>> 3"".


I understood that it's 9-18 % faster. That is significant but it's
still a performance optimization only, not an important bug fix, and to
me the code doesn't feel completely ready yet (for example, the
unaligned access is important to get right).

(Compare to the threaded decompression support that is coming to XZ
Utils. It will speed things up a few hundred percent.)

Can you provide a complete patch to make testing easier (or if not
possible, complete copies of modified files)? Also, please try to wrap
the lines so that they stay within 80 columns (with some long
unbreakable strings this may not be possible, then those lines can be
overlong instead of messing up the indentation).

I think your patch will find its way into XZ for Java in some form
but once again I repeat that it will take some time. These XZ projects
are only a hobby for me and currently I don't even turn on my computer
every day.

-- 
Lasse Collin  |  IRC: Larhzu @ IRCnet & Freenode
",Re: [xz-devel] xz-java and newer java,msg00426.html
"Thu, 21 Jan 2021 17:47:17 -0800",Brett Okken,Brett Okken,"

I have now run benchmarks using the 32bit jre on 64bit windows system.
That actually introduces additional interesting impacts by using the
client jvm by default, which does not use the c2 compiler. The longs
appear to be a bit faster in client mode (not as optimized) and the
ints a bit faster in server mode.


Somewhat surprisingly, this actually appears to make things slightly
worse by having to introduce the check to see a detected difference
was beyond the actual length.


Nice catch. Arrays approaching 2GB are not common yet, but seems
likely in future.


This is a bit trickier. The closest I can find to documentation is
from the getInt method[1].

The object referred to by o is an array, and the offset is an integer
of the form B+N*S, where N is a valid index into the array, and B and
S are the values obtained by arrayBaseOffset and arrayIndexScale
(respectively) from the array's class. The value referred to is the
Nth element of the array.
...
However, the results are undefined if that variable is not in fact of
the type returned by this method.

Taken in context with what the new
jdk.internal.misc.Unsafe.getLongUnaligned implementation looks like[2]
unaligned access is not safe with Unsafe.getLong.


I /might/ be able to run some benchmarks on aws graviton2 instances.

I will send out updated code soon, but I currently have
implementations for jdk 9+ to use VarHandle for x86 (ints for 32bit
longs for 64 bit) and non-x86 to use the vectorized Arrays mismatch.
For older jdks, x86 will use Unsafe (again, ints for 32 bit and longs
for 64 bit). There are also implementations for VarHandles which will
make an attempt to compare individual bytes to try and get memory
reads into alignment. The default implementation behavior can be
overridden by setting a system property.

[1] - 
https://github.com/openjdk/jdk11u-dev/blob/master/src/jdk.unsupported/share/classes/sun/misc/Unsafe.java#L127-L139
[2] - 
https://github.com/openjdk/jdk11u-dev/blob/master/src/java.base/share/classes/jdk/internal/misc/Unsafe.java#L3398
",Re: [xz-devel] xz-java and newer java,msg00433.html
